package com.crypto;


import com.util.text.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.HashMap;
import java.util.Map;

/**
 * Provides support for storing hashed passwords. Note that it is impossible to discover the password from the hash and salt in any reasonable time frame.
 * <p/>
 * Every user should have a "salt" - this should be generated by the generateSalt() method and never changed.
 * <p/>
 * When the user password is created or changed, the getHash() is called with the password, and the result stored against the user.
 * <p/>
 * To authenticate a login, call getHash with the supplied password and the user's salt, and check that it matches the stored password hash.
 * <p/>
 * See https://howtodoinjava.com/security/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/ for an explanation of why we do it this way.
 */
public final class PasswordHash {

    private static final Logger logger = LoggerFactory.getLogger(PasswordHash.class);



    private final static Map<Integer, PasswordEncoder> passwordEncoder = new HashMap<Integer, PasswordEncoder>() {
        {
            put(1, HashPasswordEncoder.getInstance());
            put(2, Argon2PasswordEncoder.getInstance());
            put(3, Pbkdf2PasswordEncoder.getInstance());
        }
    };



    private PasswordHash() {
    }

    /**
     * Validates a password using a hash.
     * Verify that the encoded password obtained from storage matches the submitted raw
     * password after it is too encoded. Returns true if the passwords match, false if
     * they do not. The stored password itself is never decoded.
     *
     * @param password               the password to check
     * @param hashedPasswordWithSalt the stored hashed password with salt
     * @return true if the password is correct, false if not
     */
    public static boolean matches(String password, String hashedPasswordWithSalt)  {
        if (StringUtils.isEmpty(hashedPasswordWithSalt)) {
            logger.warn("password hash is null");
            return false;
        }
        final String[] params = hashedPasswordWithSalt.split(":");
        if  (params.length != 3){
            return HashHmacPasswordEncoder.getInstance().matches(password, hashedPasswordWithSalt);
        }
        final Integer alg = Integer.valueOf(params[2]);
        return passwordEncoder.getOrDefault(alg, Pbkdf2PasswordEncoder.getInstance()).matches(password, hashedPasswordWithSalt);
    }

    /**
     * Returns a salted hash of the password.
     *
     * @param password the password to hash
     * @return a salted PBKDF2 hash of the password
     */
    public static String encode(String password) {
        logger.debug("Encoding password");
        return Pbkdf2PasswordEncoder.getInstance().encode(password);
    }

    public static String encode(String password, int algorithm) {
        logger.debug("Encoding password");
        return passwordEncoder.getOrDefault(algorithm, Pbkdf2PasswordEncoder.getInstance()).encode(password);
    }







}
